import { Node } from 'reactflow';

/**
 * Generates PlantUML constraints based on node positions.
 * Strategy:
 * 1. Remove existing layout constraints generated by this tool.
 * 2. Sort nodes by Y (rows) and X (columns).
 * 3. Generate -[hidden]right-> for horizontal neighbors.
 * 4. Generate -[hidden]down-> for vertical neighbors.
 */

const LAYOUT_START_MARKER = "' @LAYOUT_START";
const LAYOUT_END_MARKER = "' @LAYOUT_END";

export const generateLayoutConstraints = (nodes: Node[]): string => {
    if (nodes.length === 0) return "";

    let constraints = `\n${LAYOUT_START_MARKER}\n`;

    // 1. Sort nodes to understand topology
    // Sort primarily by Y (tolerance 50px for "same row"), secondarily by X
    const sortedNodes = [...nodes].sort((a, b) => {
        const yDiff = a.position.y - b.position.y;
        if (Math.abs(yDiff) < 50) {
            return a.position.x - b.position.x;
        }
        return yDiff;
    });

    // 2. Generate Horizontal Constraints (Row structure)
    // Link node[i] -> node[i+1] if they are on the same "row"
    for (let i = 0; i < sortedNodes.length - 1; i++) {
        const curr = sortedNodes[i];
        const next = sortedNodes[i + 1];

        // Check if on same row (y difference is small)
        if (Math.abs(curr.position.y - next.position.y) < 60) {
             // If next is to the right
             if (next.position.x > curr.position.x) {
                 constraints += `${curr.id} -[hidden]right-> ${next.id}\n`;
             }
        }
    }

    // 3. Generate Vertical Constraints (Column structure)
    // This is computationally O(N^2) but fine for small diagrams.
    // For each node, find the closest node directly below it.
    sortedNodes.forEach(upper => {
        let closestLower: Node | null = null;
        let minDistance = Infinity;

        sortedNodes.forEach(lower => {
            if (lower.id === upper.id) return;
            
            // Must be below
            if (lower.position.y > upper.position.y + 50) {
                // Check if roughly aligned horizontally (within 80px width)
                if (Math.abs(lower.position.x - upper.position.x) < 80) {
                    const dist = lower.position.y - upper.position.y;
                    if (dist < minDistance) {
                        minDistance = dist;
                        closestLower = lower;
                    }
                }
            }
        });

        if (closestLower) {
            // @ts-ignore
            constraints += `${upper.id} -[hidden]down-> ${closestLower.id}\n`;
        }
    });

    constraints += `${LAYOUT_END_MARKER}`;
    return constraints;
};

export const applyLayoutToCode = (originalCode: string, constraints: string): string => {
    // Remove old layout block if exists
    const regex = new RegExp(`${LAYOUT_START_MARKER}[\\s\\S]*?${LAYOUT_END_MARKER}`, 'g');
    let cleanCode = originalCode.replace(regex, '').trim();

    // Ensure @enduml is at the very end
    cleanCode = cleanCode.replace('@enduml', '');
    
    return `${cleanCode.trim()}\n${constraints}\n@enduml`;
};
